#include <iostream>
#include <unordered_map>
#include <fstream>
#include "Queue.h"
#include <vector>
#include <set>
using namespace std;
// Add edge
string difference(string cs1, string cs2) {
    string d= "" ;
    int i=0;
    int k=0;
    for (; i<cs1.length() && k<cs2.length(); ) {
        if(cs1.length()<=cs2.length()){
        if (cs1[i] != cs2[k] && k<=i) {
            d+=cs2[i];

        } else if((cs1[i] != cs2[k] && i<=k))
            d+=cs2[k];}
        else{
            difference(cs2,cs1);

        }

        if(i==cs1.length()-1 && k!=cs2.length()-1){
            k++;

        } else if(i!=cs1.length()-1 && k==cs2.length()-1){
            i++;
        }
        else{
            k++;
            i++;
        }

    }
    if(d.length() == 1)
        return d;
    else
        return string();
}

struct Vertex{
    bool known;
    int dist;
    string path;
    string value;
    Vertex() : known(false),dist(2^31 - 1)
    {}
};

void addEdge(vector<Vertex> adj[], Vertex v,Vertex w,int index1,int index2) {
    adj[index1].push_back(w);

}


// Print the graph
void displayAdjList(vector<Vertex> adj_list[], int v) {
    for (int i = 0; i < v; i++) {
        cout << i  << "--->";
        vector<Vertex>::iterator it;
        for (it = adj_list[i].begin(); it != adj_list[i].end(); ++it) {
            cout << it->value << " ";
        }
        cout << endl;
    }
}



void WordSearch(string word1,string word2,unordered_map<string,bool>&d,set<string>&words) {
    Queue q;
    string temp;
    int dis = 0;
    q.enqueue(word1);

    while (!q.empty()) {
        temp = q.front();
        d[temp] = true;
        q.pop();
        if (temp == word2) {
            cout << temp << endl;
            return;
        } else {
            for (int i = 0; i < q.size(); i++) {
            }


        }


    }
}
void Graph(Vertex s,set<string>Vertices,vector<Vertex>adjecent[])
{
    queue<Vertex> q;
    Vertex v, w;
    q.push(s);
    s.dist = 0;

    while(! q.empty( )) {
        v = q.front( );
        q.pop();
        v.known = true;
        for (int i = 0; i < Vertices.size(); ++i) {
            if (w.dist == 2^31 - 1) {
                w.dist = v.dist + 1;
                w.path = v.value;
                q.push(w);
            }


        }

    }
}

int main() {
    unordered_map<string,bool> dictionary;
    ifstream file("words.txt");
    string words,word1,word2,temp;

    std::set<string>::iterator it;
    std::set<string>::iterator it2;

    while(file>>words){
        dictionary[words]= false;
    }
    file.close();
    file.open("words.txt");


    while (word1[0]!= '*') {
        set<string>wordSet;
        cout << "Please enter two words :";
        cin >> word1>>word2;
        if(dictionary.find(word1)==dictionary.end() || dictionary.find(word2)== dictionary.end() ){   //Check if the words in the dictionary
            cout<<"One of the words is not in the dictionary ,please enter new words!! "<<endl;
        }
        else {
            while (file >> words) {
                if (abs(int(word1.length()) - int(words.length())) <= abs(int(word1.length()) -
                                                                          int(word2.length()))) { //uzunluk farkı aranan kelimeler arasında farka eşit olan kelimeleri al
                    wordSet.insert(words);
                }

            }
            vector<Vertex>adjecentEdges[wordSet.size()];
            string tmp1,tmp2;
            Vertex List[wordSet.size()];
            int index1=0;
            int index2=0;
            for (it = wordSet.begin(); it != wordSet.end(); it++) {
                tmp1=*it;
                Vertex v;
                v.value=tmp1;
                List[index1]=v;
                for (it2 = wordSet.begin(); it2 != wordSet.end(); it2++) {
                    Vertex w;
                    tmp2=*it2;
                    w.value=tmp2;
                    if(tmp1!=tmp2 && difference(tmp1,tmp2) !="") {
                            addEdge(adjecentEdges,v,w,index1,index2);
                    }

                    }
                index1++;
                }
            Vertex s;
            s.value=word1;
            Graph(s,wordSet,adjecentEdges);
            displayAdjList(adjecentEdges,wordSet.size());
            }

    }


    return 0;
}
